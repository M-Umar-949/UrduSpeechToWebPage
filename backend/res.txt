!ngrok config add-authtoken 2pYoo3l16f4rmZbjHEhGIXPv0Je_xMciC7f3kamyBYFEtgF

import os
import sounddevice as sd
import scipy.io.wavfile as wav
from pydub import AudioSegment
from groq import Groq
from dotenv import load_dotenv
import threading
import time
from datetime import datetime

# Load environment variables from the .env file
load_dotenv()

RECORDING_FILE_WAV = "recording.wav"
RECORDING_FILE_M4A = "recording.m4a"
is_recording = False
recording_thread = None

def transcribe_audio(filename):
    """Transcribe the audio file using Groq and save the transcript."""
    api_key = os.getenv("GROQ_SECRET_ACCESS_KEY")
    if not api_key:
        print("Error: GROQ_SECRET_ACCESS_KEY not found.")
        return None

    try:
        client = Groq(api_key=api_key)
        with open(filename, "rb") as file:
            transcription = client.audio.transcriptions.create(
                file=(filename, file.read()),
                model="whisper-large-v3-turbo",
                language="en",
                response_format="text"
            )
        
        # Save transcript to a file with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        transcript_filename = f"transcript_{timestamp}.txt"
        
        with open(transcript_filename, "w") as transcript_file:
            transcript_file.write(transcription)
        
        print(f"Transcription saved to {transcript_filename}")
        print("Transcription:", transcription)
        
        return transcription
    
    except Exception as e:
        print(f"Transcription error: {e}")
        return None

def record_audio(duration=10, samplerate=44100):
    """Record audio from the microphone."""
    global is_recording
    print("Recording started...")
    is_recording = True
    recording = sd.rec(int(duration * samplerate), samplerate=samplerate, channels=1, dtype='int16')
    sd.wait()
    wav.write(RECORDING_FILE_WAV, samplerate, recording)
    print("Recording stopped.")
    is_recording = False

def convert_wav_to_audio(output_format='mp3'):
    """Convert the WAV file to another audio format."""
    try:
        output_filename = f"recording.{output_format}"
        audio = AudioSegment.from_wav(RECORDING_FILE_WAV)
        audio.export(output_filename, format=output_format)
        print(f"Audio converted to {output_format} format.")
        return output_filename
    except Exception as e:
        print(f"Conversion error: {e}")
        return RECORDING_FILE_WAV

def start_recording():
    """Start audio recording in a separate thread."""
    global recording_thread
    recording_thread = threading.Thread(target=record_audio)
    recording_thread.start()

def stop_recording_and_transcribe():
    """Stop recording, wait for completion, convert audio, and transcribe."""
    global is_recording, recording_thread
    
    if is_recording:
        print("Recording is still in progress. Waiting to complete...")
        # Wait for the recording to finish
        if recording_thread:
            recording_thread.join()
    
    # Convert to MP3 (more reliable than M4A)
    converted_file = convert_wav_to_audio('mp3')
    
    # Transcribe the converted audio file
    transcript = transcribe_audio(converted_file)
    return transcript

if __name__ == "__main__":
    print("Press 's' to start recording and 'e' to stop and transcribe.")
    
    while True:
        user_input = input("Enter command: ").strip().lower()
        if user_input == 's':
            if is_recording:
                print("Recording is already in progress.")
            else:
                start_recording()
        elif user_input == 'e':
            stop_recording_and_transcribe()
        elif user_input == 'q':
            print("Exiting...")
            break
        else:
            print("Invalid input. Press 's' to start, 'e' to stop, or 'q' to quit.")